// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.subsystems;

import com.ctre.phoenix.motorcontrol.ControlMode;

import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.command.Subsystem;

import frc.robot.RobotMap;
import frc.robot.commands.OpenLoopDrive;

/**
 * Subsystem representing the robot drivetrain and all ways it can be controlled
 */
public class DriveTrain extends Subsystem {
	// Global Varibles
	public static final double MAX_LOW_SPEED = 1900.0;
	public static final double MIN_HIGH_SPEED = 2100.0;
	public static final double S_MS_MULTIPLIER = 1000.0;
	public static final int SENSOR_POSITION_TIMEOUT = 10;
	public static final double TURN_ERROR_SCALING = 0.02;

	// Class Variables
	private boolean reversed;

	public double averageVelocity = 0.0;
	public double leftSideSwitchSide = 0.0;
	public double rightSideSwitchSide = 0.0;
	public double integral = 0.0;
	public double previousError = 0.0;
	public double previousDesiredAngle = 0.0;
	public double previousDesiredDistance = 0.0;

	// Setup our timed drive
	private double currentTime = 0.0;
	private double endTime = 0.0;

	@Override
	public void initDefaultCommand() {
		setDefaultCommand(new OpenLoopDrive());
	}

	 // Tank drive
	public void takeJoystickInputs(Joystick left, Joystick right) {
		RobotMap.left1.set(ControlMode.PercentOutput, left.getY());
		RobotMap.right1.set(ControlMode.PercentOutput, right.getY());
	}

	// Arcade drive
	public void takeStickInputValues(double leftStickV, double rightStickV) {
		if (!reversed) {
			RobotMap.left1.set(ControlMode.PercentOutput, -leftStickV);
			RobotMap.right1.set(ControlMode.PercentOutput, rightStickV);
		} else {
			RobotMap.left1.set(ControlMode.PercentOutput, -rightStickV);
			RobotMap.right1.set(ControlMode.PercentOutput, leftStickV);
		}
	}

	public void ArcadeDrive(double robotOutput, double turnAmount) {
		if (!reversed) {
			// SmartDashboard.putNumber("turnamount", turnAmount);
			RobotMap.left1.set(ControlMode.PercentOutput, (-robotOutput) + turnAmount);
			RobotMap.right1.set(ControlMode.PercentOutput, robotOutput + turnAmount);
		} else {
			RobotMap.left1.set(ControlMode.PercentOutput, (robotOutput) + turnAmount);
			RobotMap.right1.set(ControlMode.PercentOutput, -robotOutput + turnAmount);
		}
	}

	public void RacingDrive(double robotOutput, double turnAmount) {
		double outputLeft = -robotOutput + turnAmount;
		double outputRight = robotOutput + turnAmount;
		double max = outputLeft < outputRight ? outputRight : outputLeft;
		double multiplier;

		if (max > RobotMap.DRIVE_LIMITER)
			multiplier = RobotMap.DRIVE_LIMITER / (max);
		else
			multiplier = 1;

		outputLeft *= multiplier;
		outputRight *= multiplier;

		if (reversed) {
			double temp = outputLeft;
			outputLeft = outputRight;
			outputRight = temp;
		}

		RobotMap.left1.set(ControlMode.PercentOutput, outputLeft * RobotMap.speedMultiplier);
		RobotMap.right1.set(ControlMode.PercentOutput, outputRight * RobotMap.speedMultiplier);
	}

	// Welcome to the Amazing World of PID! (Population: 3, just P, I, and D)

	private double convertToRotations(double distanceInFeet) {
		return distanceInFeet / (Math.PI * (RobotMap.WHEEL_RADIUS * 2.0));
	}

	public void driveForSeconds(double seconds, double leftInput, double rightInput) {
		currentTime = System.currentTimeMillis();
		endTime = System.currentTimeMillis() + (seconds * S_MS_MULTIPLIER);

		while (currentTime < endTime) {
			currentTime = System.currentTimeMillis();
			RobotMap.left1.set(ControlMode.PercentOutput, leftInput);
			RobotMap.right1.set(ControlMode.PercentOutput, rightInput);
		}
		stop();
	}

	public double ticksToRot(double ticks) {
		return ticks / 7610;
	}

	public double ticksToIn(double ticks) {
		double circumf = Math.PI * 7.5;
		return ticksToRot(ticks) * circumf;
	}

	double currentDistance = 0.0;
	double driveError = 0.0;

	public boolean driveToPosition(double desiredDistance) {
		// Checks if the target has changed.
		// If it has changed, reset the base variables to 0.

		if (desiredDistance != previousDesiredDistance) {
			integral = 0.0;
			previousError = 0.0;
			previousDesiredDistance = desiredDistance;
		}
		currentDistance = ticksToIn(RobotMap.left1.getSelectedSensorPosition());

		driveError = desiredDistance - currentDistance;
		integral += driveError * .02;
		double derivative = (driveError - previousError) / .02;
		double speed = RobotMap.DRIVE_kP * driveError + RobotMap.DRIVE_kI * integral + RobotMap.DRIVE_kD * derivative;

		RobotMap.left1.set(ControlMode.PercentOutput, speed);
		RobotMap.right1.set(ControlMode.PercentOutput, speed);

		if (driveError < RobotMap.DRIVE_ERROR_CONSTANT && driveError > -RobotMap.DRIVE_ERROR_CONSTANT) {
			return true;
		}
		return false;
	}

	public void driveToPositionEnd() {
		RobotMap.left1.setSelectedSensorPosition(0, 0, 10);
		RobotMap.right1.setSelectedSensorPosition(0, 0, 10);
	}

	public double getLeftEncoderPosition() {
		return RobotMap.left1.getSelectedSensorPosition(0);
	}

	public double getRightEncoderPosition() {
		return RobotMap.right1.getSelectedSensorPosition(0);
	}

	public double getLeftEncoderVelocity() {
		return -RobotMap.left1.getSelectedSensorVelocity(0);
	}

	public double getRightEncoderVelocity() {
		return RobotMap.right1.getSelectedSensorVelocity(0);
	}

	public void stop() {
		RobotMap.left1.set(ControlMode.PercentOutput, 0);
		RobotMap.right1.set(ControlMode.PercentOutput, 0);
	}

	public boolean isReversed() {
		return reversed;
	}

	public void switchFront() {
		reversed = !reversed;
	}

	public void resetEncoders() {
		RobotMap.left1.setSelectedSensorPosition(0, 0, SENSOR_POSITION_TIMEOUT);
		RobotMap.right1.setSelectedSensorPosition(0, 0, SENSOR_POSITION_TIMEOUT);
	}
}
