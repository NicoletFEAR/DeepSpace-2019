// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.subsystems;

import frc.robot.*;
import frc.robot.commands.*;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.SensorCollection;

import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.DoubleSolenoid;

/**
 * Subsystem representing the robot drivetrain and all ways it can be
 * controlled.
 */
public class DriveTrain extends Subsystem {
	/* Global Varibles */
	public static final double MAX_LOW_SPEED = 1900.0;
	public static final double MIN_HIGH_SPEED = 2100.0;
	public static final double S_MS_MULTIPLIER = 1000.0;
	public static final int SENSOR_POSITION_TIMEOUT = 10;
	public static final double TURN_ERROR_SCALING = 0.02;

	/* Class Variables */
	private boolean reversed;

	/* Shared DriveTrain PID Variables */
	public double integral = 0.0;
	public double previousError = 0.0;
	public double previousDesiredAngle = 0.0;
	public double previousDesiredDistance = 0.0;

	/* Setup our timed drive */
	private double currentTime = 0.0;
	private double endTime = 0.0;

	/**
	 * Should run a test command for the drivetrain, does nothing right now...
	 */
	public void testCommand() {
	}

	/**
	 * Sets the method to run while this subsystem is running. For this subsystem,
	 * openloop driving is started up.
	 */
	@Override
	public void initDefaultCommand() {
		setDefaultCommand(new OpenLoopDrive());
	}

	/**
	 * Control the robot in a racing style drive. (Think of how you'd control a race
	 * car in Forza Motor Sports)
	 * 
	 * @param robotOutput power used to move robot forwards and backwards
	 * @param turnAmount  power used into turning the robot
	 */
	public void racingDrive(double robotOutput, double turnAmount) {
		double outputLeft = -robotOutput + turnAmount;
		double outputRight = robotOutput + turnAmount;
		double max = outputLeft < outputRight ? outputRight : outputLeft;
		double multiplier;
		if (max > RobotMap.DRIVE_LIMITER)
			multiplier = RobotMap.DRIVE_LIMITER / (max);
		else
			multiplier = 1;

		outputLeft *= multiplier;
		outputRight *= multiplier;

		if (reversed) {
			double temp = outputLeft;
			outputLeft = outputRight;
			outputRight = temp;
		}

		RobotMap.left1.set(ControlMode.PercentOutput, outputLeft);
		RobotMap.right1.set(ControlMode.PercentOutput, outputRight);

		// SmartDashboard.putData("Drive Train", robotDrive);
		// SmartDashboard.putNumber("Left Side", leftSide.get());
		// SmartDashboard.putNumber("Right Side", rightSide.get());

		// SmartDashboard.putNumber("sensor analogin", sensorRight.getAnalogIn());
		// SmartDashboard.putNumber("sensor analoginraw", sensorRight.getAnalogInRaw());
		// SmartDashboard.putNumber("sensor analongvel", sensorRight.getAnalogInVel());
		// SmartDashboard.putNumber("sensor widthpos",
		// sensorRight.getPulseWidthPosition());
		// SmartDashboard.putNumber("sensor velocity",
		// sensorRight.getQuadratureVelocity());
	}

	/* Welcome to the Amazing World of PID! (Population: 3, just P, I, and D) */

	/**
	 * Drives the robot for a set amount of seconds with a set amount of speed for
	 * each side of the robot.
	 * 
	 * @param seconds    how long to drive for in seconds
	 * @param leftInput  speed for left side of robot
	 * @param rightInput speed for right side of robot
	 */
	public void driveForSeconds(double seconds, double leftInput, double rightInput) {
		currentTime = System.currentTimeMillis();
		endTime = System.currentTimeMillis() + (seconds * S_MS_MULTIPLIER);
		while (currentTime < endTime) {
			currentTime = System.currentTimeMillis();
			RobotMap.left1.set(ControlMode.PercentOutput, leftInput);
			RobotMap.right1.set(ControlMode.PercentOutput, rightInput);
		}
		stop();
	}

	// Some special isFinished() command stuff to not stop before the robot has
	// even moved

	/**
	 * 
	 * @param ticks
	 * @return
	 */
	public double ticksToRot(double ticks) {
		return ticks / 7610;
	}

	/**
	 * 
	 * @param ticks
	 * @return
	 */
	public double ticksToIn(double ticks) {
		double circumf = Math.PI * 7.5;
		return ticksToRot(ticks) * circumf;
	}

	double currentDistance = 0.0;
	double driveError = 0.0;

	/**
	 * 
	 * @param desiredDistance
	 * @return
	 */
	public boolean driveToPosition(double desiredDistance) {
		// checks if the target has changed
		// if it has changed, reset the base variables to 0;

		if (desiredDistance != previousDesiredDistance) {
			integral = 0.0;
			previousError = 0.0;
			previousDesiredDistance = desiredDistance;
		}
		currentDistance = ticksToIn(RobotMap.left1.getSelectedSensorPosition());

		driveError = desiredDistance - currentDistance;
		integral += driveError * .02;
		double derivative = (driveError - previousError) / .02;
		double speed = RobotMap.DRIVE_kP * driveError + RobotMap.DRIVE_kI * integral + RobotMap.DRIVE_kD * derivative;

		RobotMap.left1.set(ControlMode.PercentOutput, speed);
		RobotMap.right1.set(ControlMode.PercentOutput, speed);

		if (driveError < RobotMap.DRIVE_ERROR_CONSTANT && driveError > -RobotMap.DRIVE_ERROR_CONSTANT) {
			return true;
		}
		return false;
	}

	public void driveToPositionEnd() {
		RobotMap.left1.setSelectedSensorPosition(0, 0, 10);
		RobotMap.right1.setSelectedSensorPosition(0, 0, 10);
	}

	double turnError = 0.0;
	double startingAngle = 0.0;

	public boolean turnToAngle(double desiredAngle) {
		// checks if the target has changed
		// if it has changed, reset the base variables to 0
		if (desiredAngle != previousDesiredAngle) {
			integral = 0;
			previousError = 0;
			previousDesiredAngle = desiredAngle;
			startingAngle = Robot.navX.getAngle();
		}

		double currentAngle = Robot.navX.getAngle();

		turnError = (desiredAngle + startingAngle) - currentAngle;

		SmartDashboard.putNumber("turnError", turnError);

		integral += turnError * TURN_ERROR_SCALING;

		double derivative = (turnError - previousError) / TURN_ERROR_SCALING;
		double speed = RobotMap.TURN_kP * turnError + RobotMap.TURN_kI * integral + RobotMap.TURN_kD * derivative;

		SmartDashboard.putNumber("turnToAngleSpeed", speed);

		racingDrive(0, speed);

		/*
		 * if (desiredAngle > 0) { RobotMap.right1.set(ControlMode.PercentOutput,
		 * -speed); RobotMap.left1.set(ControlMode.PercentOutput, speed); } else {
		 * RobotMap.right1.set(ControlMode.PercentOutput, speed);
		 * RobotMap.left1.set(ControlMode.PercentOutput, -speed); }
		 */

		if (turnError < RobotMap.TURN_ERROR_CONSTANT && turnError > -RobotMap.TURN_ERROR_CONSTANT) {
			integral = 0;
			previousError = 0;
			previousDesiredAngle = 0.1;
			desiredAngle = 0;
			return true;
		}

		previousError = turnError;
		return false;
	}

	/**
	 * 
	 * @return
	 */
	public double getLeftEncoderPosition() {
		return (RobotMap.left1.getSelectedSensorPosition(0));
	}

	/**
	 * 
	 * @return
	 */
	public double getRightEncoderPosition() {
		// Make sure graph isn't upside down (The stocks are going into the
		// toilet!!)
		return (RobotMap.right1.getSelectedSensorPosition(0));
	}

	/**
	 * @return
	 */
	public double getLeftEncoderVelocity() {
		return -RobotMap.left1.getSelectedSensorVelocity(0);
	}

	/**
	 * 
	 * @return
	 */
	public double getRightEncoderVelocity() {
		// Make sure graph isn't upside down (The stocks are going into the
		// toilet!!)
		return (RobotMap.right1.getSelectedSensorVelocity(0));
	}

	/**
	 * Stops the motors, and thus stops the robot's movement.
	 */
	public void stop() {
		RobotMap.left1.set(ControlMode.PercentOutput, 0);
		RobotMap.right1.set(ControlMode.PercentOutput, 0);
	}

	/**
	 * Convenience method that returns if the robot's controls are reversed.
	 * @return is the robot's controls reversed
	 */
	public boolean isReversed() {
		return reversed;
	}

	/**
	 * Switches the front side of the robot,
	 * so that forward on your controller will be backward for the robot.
	 */
	public void switchFront() {
		// RobotMap.left1.setInverted(!RobotMap.left1.getInverted());
		// RobotMap.left2.setInverted(!RobotMap.left2.getInverted());
		// RobotMap.left3.setInverted(!RobotMap.left3.getInverted());
		// RobotMap.right1.setInverted(!RobotMap.right1.getInverted());
		// RobotMap.right2.setInverted(!RobotMap.right2.getInverted());
		// RobotMap.right3.setInverted(!RobotMap.right3.getInverted());
		reversed = !reversed;
	}

	/**
	 * Resets the encoders' measured positions to 0.
	 */
	public void resetEncoders() {
		RobotMap.left1.setSelectedSensorPosition(0, 0, SENSOR_POSITION_TIMEOUT);
		RobotMap.right1.setSelectedSensorPosition(0, 0, SENSOR_POSITION_TIMEOUT);
	}
}
