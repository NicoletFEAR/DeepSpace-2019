// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.commands;
import edu.wpi.first.wpilibj.command.Command;
import frc.robot.Robot;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.can.TalonSRX;
// import frc.robot.RobotMap;
// import frc.robot.subsystems.DriveTrain;
import frc.robot.RobotMap;

// import com.ctre.phoenix.motorcontrol.ControlMode;

// import frc.robot.OI;
//import edu.wpi.first.wpilibj.GenericHID;
// import edu.wpi.first.wpilibj.GenericHID.Hand;
/**
 *
 */
public class DriveArc extends Command {
    int count;
    double x;
    double y;
    double theta;
    double circR;
    double circL;
    double p = 0.0005;
    double i = 0.00001;
    double d = 0.00000003;
    double integralL = 0;
    double integralR = 0;
    double previousErrorL = 0;
    double previousErrorR = 0;
    double previousDesiredEncoderValue = -10;
    boolean completeL;
    boolean completeR;
    

    public DriveArc() {
        requires(Robot.driveTrain);
    }

    public DriveArc(double x, double y, double theta){
        this.x=x;
        this.y=y;
        this.theta=theta;
        
    }

    public boolean arcDrive(double arcLength, TalonSRX talon){
        double error = arcLength - talon.getSelectedSensorPosition();
        double derivative;
        double integral;
        if(count%2==0){
            integral = integralL;
            derivative =  (error-previousErrorL)/.02;
            previousErrorL=error;
        }else{
            integral = integralR;
            derivative =  (error-previousErrorR)/.02;
            previousErrorR=error;
        }
        count++;
        double speed = p*error + i*integral + d*derivative;
        talon.set(ControlMode.PercentOutput, speed);
        
        if(error == 0 ) return true;
		return false;
    }
    
    @Override
    protected void initialize() {
        count=0;
        Robot.driveTrain.resetEncoders();
        //calculate the distance that the different sides of 
        //the robot have to travel during the arc.
        double w = 20.5;
        double r0 = y/Math.sin(theta);
        double cLeft = 0;
        double cRight = 0;
        double rLeft = 0;
        double rRight = 0;
        //this is saying that you are turnin right
        //cricR is the radius of the inner circl
        if (x > 0){
            rRight = r0 - (1/2)*w;
            rLeft = r0 + (1/2)*w;
        }else{
            rRight = r0 + (1/2)*w;
            rLeft = r0 - (1/2)*w;
        }
        
        cRight = rRight*Math.PI*2;
        cLeft = rLeft*Math.PI*2;

        circR = cRight*(theta/360);
        circL = cLeft*(theta/360);

        completeL=false;
        completeR=false;        
    }

    @Override
    protected void execute() {	
        if(!completeL) completeL = arcDrive(circL, RobotMap.frontLeft);
        if(!completeR) completeR = arcDrive(circR, RobotMap.frontRight);
        // completeL = Robot.driveTrain.DriveArc(circL, RobotMap.frontLeft);
        // completeR = Robot.driveTrain.DriveArc(circR, RobotMap.frontRight);
    }

    @Override
    protected boolean isFinished() {
        return completeL && completeR;
    }
    // Called once after isFinished returns true
    @Override
    protected void end() {
    	Robot.driveTrain.stop();
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
    	end();
    }
}
